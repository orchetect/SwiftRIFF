//
//  Test Data.swift
//  SwiftRIFF • https://github.com/orchetect/SwiftRIFF
//  © 2025-2025 Steffan Andrews • Licensed under MIT License
//

enum SampleWAV {
    // (all integers are stored little-endian)
    // note that this mocks the structure of a wave file for purposes of unit testing,
    // but does not actually contain a valid wave file data chunk.
    // it is however correctly formatted as a RIFF file.
    static let fileBytes: [UInt8] = [
        // start of file
        0x52, 0x49, 0x46, 0x46, // "RIFF"
        0x28, 0x00, 0x00, 0x00, // Total file length minus 8 bytes == int 40
        0x57, 0x41, 0x56, 0x45, // "WAVE" file type
        0x66, 0x6D, 0x74, 0x20, // “fmt "
        0x10, 0x00, 0x00, 0x00, // Format chunk length == int 16
        0x01, 0x00, // Format type. PCM == int 1
        0x02, 0x00, // Number of channels == int 2
        0x80, 0xBB, 0x00, 0x00, // Sample Rate == int 48_000
        0x00, 0x65, 0x04, 0x00, // (SampleRate * BitsPerSample * Channels) / 8 == int 288_000
        0x06, 0x00, // (BitsPerSample * Channels) / 8 == int 6
        0x18, 0x00, // Bits per sample == int 24
        0x64, 0x61, 0x74, 0x61, // "data" chunk ID
        0x03, 0x00, 0x00, 0x00, // Data chunk length == int 3
        0x01, 0x02, 0x03, 0x00 // 3 bytes of data + 1 byte of null padding
    ]
}

enum SampleWAV2 {
    // note that this mocks the structure of a wave file for purposes of unit testing,
    // but does not actually contain a valid wave file data chunk.
    // it is however correctly formatted as a RIFF file.
    static let fileBytes: [UInt8] = [
        // start of file
        0x52, 0x49, 0x46, 0x46, // "RIFF"
        0x28, 0x00, 0x00, 0x00, // Total file length minus 8 bytes == int 40
        0x57, 0x41, 0x56, 0x45, // "WAVE" file type
        0x66, 0x6D, 0x74, 0x20, // “fmt "
        0x14, 0x00, 0x00, 0x00, // Format chunk length == int 20
        0x01, 0x00, // Format type. PCM == int 1
        0x02, 0x00, // Number of channels == int 2
        0x80, 0xBB, 0x00, 0x00, // Sample Rate == int 48_000
        0x00, 0x65, 0x04, 0x00, // (SampleRate * BitsPerSample * Channels) / 8 == int 288_000
        0x06, 0x00, // (BitsPerSample * Channels) / 8 == int 6
        0x18, 0x00, // Bits per sample == int 24
        0x02, 0x00, 0x03, 0x04, // extra format bytes
        0x64, 0x61, 0x74, 0x61, // "data" chunk ID
        0x03, 0x00, 0x00, 0x00, // Data chunk length == int 3
        0x01, 0x02, 0x03, 0x00 // 3 bytes of data + 1 byte of null padding
    ]
}

enum SampleBWAV {
    // note that this mocks the structure of a wave file for purposes of unit testing,
    // but does not actually contain a valid wave file data chunk.
    // it is however correctly formatted as a RIFF file.
    static let fileBytes: [UInt8] = [
        // start of file
        0x52, 0x49, 0x46, 0x46, // "RIFF"
        0xCC, 0x02, 0x00, 0x00, // Total file length minus 8 bytes == int 716
        0x57, 0x41, 0x56, 0x45 // "WAVE" file type
    ] + junkChunkBytes + bextChunkBytes + fmtChunkBytes + dataChunkBytes
    // note that BWAV files often follow with numerous small additional metadata chunks after the data chunk
    
    // 72 bytes
    static let junkChunkBytes: [UInt8] = [
        0x4A, 0x55, 0x4E, 0x4B,
        0x40, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
    ]
    
    // 610 bytes
    static let bextChunkBytes: [UInt8] = [
        0x62, 0x65, 0x78, 0x74,
        0x5A, 0x02, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x50, 0x72, 0x6F, 0x20, 0x54, 0x6F, 0x6F, 0x6C,
        0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x61, 0x61, 0x69, 0x52, 0x54, 0x5A, 0x79, 0x39,
        0x51, 0x4B, 0x56, 0x6B, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x32, 0x30, 0x32, 0x35, 0x2D, 0x30, 0x36, 0x2D,
        0x31, 0x38, 0x31, 0x36, 0x3A, 0x32, 0x31, 0x3A,
        0x33, 0x34, 0x00, 0xB8, 0x4C, 0x0A, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x06, 0x0A, 0x2B, 0x34,
        0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x0F, 0x10,
        0x13, 0x00, 0x00, 0x00, 0xF9, 0x2A, 0xF5, 0x8C,
        0xED, 0xAC, 0x80, 0x00, 0x44, 0x50, 0x66, 0x8A,
        0xF3, 0xD6, 0xF6, 0x94, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00
    ]
    
    // 48 bytes
    static let fmtChunkBytes: [UInt8] = [
        0x66, 0x6D, 0x74, 0x20, // “fmt "
        0x28, 0x00, 0x00, 0x00, // Format chunk length == int 40
        0x01, 0x00, // Format type. PCM == int 1
        0x02, 0x00, // Number of channels == int 2
        0x80, 0xBB, 0x00, 0x00, // Sample Rate == int 48_000
        0x00, 0x65, 0x04, 0x00, // (SampleRate * BitsPerSample * Channels) / 8 == int 288_000
        0x06, 0x00, // (BitsPerSample * Channels) / 8 == int 6
        0x18, 0x00, // Bits per sample == int 24
        0x16, 0x00, 0x03, 0x04, // 24 extra format bytes (technically UInt16 length + 22 extra data bytes)
        0x05, 0x06, 0x07, 0x08,
        0x09, 0x10, 0x1A, 0x1B,
        0x1C, 0x1D, 0x1E, 0x1F,
        0x20, 0x21, 0x22, 0x23,
        0x24, 0x25, 0x26, 0x27
    ]
    
    // 12 bytes
    static let dataChunkBytes: [UInt8] = [
        0x64, 0x61, 0x74, 0x61, // "data" chunk ID
        0x03, 0x00, 0x00, 0x00, // Data chunk length == int 3
        0x01, 0x02, 0x03, 0x00 // 3 bytes of data + 1 byte of null padding
    ]
}
